# services/auto_engine.py
import os
import traceback
from pathlib import Path
from typing import Optional, Dict, Any

# lazy imports to avoid heavy deps during import
def _import_text():
    try:
        from services.text_engine import generate_text
        return generate_text
    except Exception as e:
        return None

def _import_ttsclient():
    try:
        from services.tts_client import TTSClient
        return TTSClient
    except Exception:
        return None

def _import_image_service():
    try:
        from services.image_engine import ImageService
        return ImageService
    except Exception:
        return None

def _import_video_service():
    try:
        from services.video_engine import VideoService
        return VideoService
    except Exception:
        return None

OUT_DIR = Path("static/outputs")
OUT_DIR.mkdir(parents=True, exist_ok=True)

class AutoEngine:
    def __init__(self):
        # resolve available backends
        self._text_fn = _import_text()
        self._TTSClientCls = _import_ttsclient()
        self._ImageCls = _import_image_service()
        self._VideoCls = _import_video_service()

        # instantiate clients if available
        self.tts_client = self._TTSClientCls() if self._TTSClientCls else None
        self.image_svc = self._ImageCls() if self._ImageCls else None
        self.video_svc = self._VideoCls() if self._VideoCls else None

    def create_pipeline(self,
                        prompt: str,
                        mode_text: Optional[str] = None,
                        want_image: bool = True,
                        want_audio: bool = True,
                        want_video: bool = True,
                        voice_filename: Optional[str] = None,
                        image_filename: Optional[str] = None,
                        video_filename: Optional[str] = None,
                        vertical: bool = True,
                        add_subtitles: bool = True,
                        max_text_len: int = 300) -> Dict[str, Any]:
        """
        Orchestrates:
          1) Text generation from prompt (if text not provided)
          2) Image generation (if requested)
          3) TTS generation (if requested)
          4) Video generation (if requested)
        Returns dict with step statuses and file paths.
        """

        result = {
            "ok": True,
            "steps": {
                "text": None,
                "image": None,
                "tts": None,
                "video": None
            },
            "errors": []
        }

        try:
            # Step 1: Text generation
            generated_text = prompt
            if self._text_fn:
                try:
                    generated_text = self._text_fn(prompt, mode=mode_text, max_length=max_text_len)
                    result["steps"]["text"] = {"ok": True, "text": generated_text}
                except Exception as e:
                    # still continue with raw prompt as fallback
                    result["steps"]["text"] = {"ok": False, "error": str(e)}
                    result["errors"].append({"step": "text", "error": str(e)})
                    generated_text = prompt
            else:
                # no text engine, use prompt as-is
                result["steps"]["text"] = {"ok": False, "error": "No text engine available; using prompt as text"}
                generated_text = prompt

            # Step 2: Image generation (if requested)
            img_path = None
            if want_image:
                if self.image_svc:
                    try:
                        img_out_name = image_filename
                        img_path = self.image_svc.generate(prompt=generated_text, out_filename=img_out_name)
                        result["steps"]["image"] = {"ok": True, "image": img_path}
                    except Exception as e:
                        traceback.print_exc()
                        result["steps"]["image"] = {"ok": False, "error": str(e)}
                        result["errors"].append({"step": "image", "error": str(e)})
                else:
                    # no image engine available
                    result["steps"]["image"] = {"ok": False, "error": "No image engine available"}
            else:
                result["steps"]["image"] = {"ok": False, "skipped": True}

            # Step 3: TTS generation (if requested)
            audio_path = None
            if want_audio:
                if self.tts_client:
                    try:
                        # use filename if given otherwise autogenerated by TTS server
                        tts_res = None
                        # tts_client has both sync and async method support; call sync
                        try:
                            tts_res = self.tts_client.synthesize(generated_text, filename=voice_filename)
                        except Exception:
                            # fallback to async variant
                            try:
                                tts_res = self.tts_client.synthesize_async(generated_text, filename=voice_filename)
                                # this returns coroutine runner result only if called directly; in client we already wrapped it
                                # but handle general case
                            except Exception:
                                # last resort: not available
                                pass

                        if isinstance(tts_res, dict):
                            # prefer downloaded path then remote_file
                            audio_path = tts_res.get("downloaded") or tts_res.get("remote_file")
                            result["steps"]["tts"] = {"ok": True, "tts_result": tts_res}
                        elif isinstance(tts_res, str):
                            audio_path = tts_res
                            result["steps"]["tts"] = {"ok": True, "file": audio_path}
                        else:
                            result["steps"]["tts"] = {"ok": False, "error": "TTS returned unexpected result", "raw": str(tts_res)}
                    except Exception as e:
                        traceback.print_exc()
                        result["steps"]["tts"] = {"ok": False, "error": str(e)}
                        result["errors"].append({"step": "tts", "error": str(e)})
                else:
                    result["steps"]["tts"] = {"ok": False, "error": "No TTS client available"}
            else:
                result["steps"]["tts"] = {"ok": False, "skipped": True}

            # Step 4: Video generation (if requested)
            video_out = None
            if want_video:
                if self.video_svc:
                    try:
                        # choose image: prefer generated image, else allow using a local path in prompt
                        chosen_image = img_path or prompt  # if image svc failed, prompt may be local path
                        # choose audio: prefer audio_path; if not present but want_video true, raise
                        if not audio_path:
                            raise RuntimeError("No audio available for video generation")

                        video_out = self.video_svc.orchestrate(
                            image_or_prompt=chosen_image,
                            audio_file=audio_path,
                            audio_text=None,
                            output_name=video_filename,
                            vertical=vertical,
                            use_lipsync=False,
                            wav2lip_repo=None,
                            add_subtitles=add_subtitles
                        )
                        result["steps"]["video"] = {"ok": True, "video": video_out}
                    except Exception as e:
                        traceback.print_exc()
                        result["steps"]["video"] = {"ok": False, "error": str(e)}
                        result["errors"].append({"step": "video", "error": str(e)})
                else:
                    result["steps"]["video"] = {"ok": False, "error": "No video engine available"}
            else:
                result["steps"]["video"] = {"ok": False, "skipped": True}

            # final attachments
            result["generated_text"] = generated_text
            result["image"] = img_path
            result["audio"] = audio_path
            result["video"] = video_out

            # if any errors but video exists, still ok
            if result["errors"] and not video_out:
                result["ok"] = False

            return result

        except Exception as e:
            traceback.print_exc()
            return {"ok": False, "error": str(e)}
